package com.drinkster.service;

import com.drinkster.model.Challenge;
import com.drinkster.model.enums.Difficulty;
import com.drinkster.model.enums.Sex;
import com.drinkster.repository.ChallengeRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ChallengeServiceTest {

    @Mock
    private ChallengeRepository challengeRepository;

    @InjectMocks
    private ChallengeService challengeService;

    private Challenge challenge;

    @BeforeEach
    void setUp() {
        challenge = new Challenge(
                "Teste de desafio",
                Difficulty.MEDIUM,
                List.of(Sex.ALL),
                0,
                5
        );
    }

    @Test
    void whenGetAllChallenges_thenReturnList() {
        when(challengeRepository.findAll()).thenReturn(Collections.singletonList(challenge));

        List<Challenge> found = challengeService.getAllChallenges();

        assertThat(found).hasSize(1);
        assertThat(found.get(0).getText()).isEqualTo("Teste de desafio");
        verify(challengeRepository, times(1)).findAll();
    }

    @Test
    void whenGetChallengesByDifficulty_thenReturnFilteredList() {
        when(challengeRepository.findByDifficulty(Difficulty.MEDIUM))
                .thenReturn(Collections.singletonList(challenge));

        List<Challenge> found = challengeService.findChallenge(Difficulty.MEDIUM);

        assertThat(found).hasSize(1);
        assertThat(found.get(0).getDifficulty()).isEqualTo(Difficulty.MEDIUM);
        verify(challengeRepository, times(1)).findByDifficulty(Difficulty.MEDIUM);
    }

    @Test
    void whenSaveChallenge_thenReturnSavedChallenge() {
        when(challengeRepository.save(any(Challenge.class))).thenReturn(challenge);

        Challenge saved = challengeService.saveChallenge(challenge);

        assertThat(saved).isNotNull();
        assertThat(saved.getText()).isEqualTo("Teste de desafio");
        verify(challengeRepository, times(1)).save(challenge);
    }
}